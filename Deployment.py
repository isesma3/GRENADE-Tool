import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt

# Constants
g = 9.81  # Gravity (m/s^2)
rho = 1.225  # Air density (kg/m^3)

# Aircraft parameters
mass = 7500  # Mass (kg)
I = [10000, 20000, 30000]  # Moments of inertia [Ixx, Iyy, Izz] (kg*m^2)

# Control surface effectiveness (example values)
elevator_effectiveness = 0.05  # Moment per unit deflection (N*m/deg)

# Target altitude
target_altitude = 1000  # Target altitude (m)

# Initial conditions for pull-up maneuver
initial_state = [50, 0, -50, 0, 0, 0, 0, -np.pi/4, 0, 0, 0, -1000]  # [u, v, w, p, q, r, phi, theta, psi, x, y, z]

def control_gains(elevator_deflection):
    """
    Adjust control gains based on the elevator deflection.
    For simplicity, assume a linear relationship.
    """
    base_Kp_theta = 1.0
    base_Kd_theta = 0.1
    base_Kp_altitude = 0.01

    # Example relationship: gains decrease with increasing deflection
    Kp_theta = base_Kp_theta / (1 + abs(elevator_deflection))
    Kd_theta = base_Kd_theta / (1 + abs(elevator_deflection))
    Kp_altitude = base_Kp_altitude / (1 + abs(elevator_deflection))

    return Kp_theta, Kd_theta, Kp_altitude

def control_law(state, target_theta):
    _, _, _, _, q, _, _, theta, _, _, _, z = state

    # Altitude error
    altitude_error = target_altitude + z  # z is negative for altitude

    # Error in pitch angle
    error_theta = target_theta - theta

    # Calculate control gains based on elevator deflection
    Kp_theta, Kd_theta, Kp_altitude = control_gains(0)  # Assume zero elevator deflection initially

    # Calculate elevator deflection needed (assuming linear relationship)
    elevator_deflection = Kp_theta * error_theta - Kd_theta * q + Kp_altitude * altitude_error

    # Clamp elevator deflection to realistic values (e.g., -15 to 15 degrees)
    elevator_deflection = np.clip(elevator_deflection, -15, 15)

    # Recalculate control gains with updated elevator deflection
    Kp_theta, Kd_theta, Kp_altitude = control_gains(elevator_deflection)

    # Calculate moment generated by elevator deflection
    My = elevator_effectiveness * elevator_deflection

    return [0, 0, -mass * g], [0, My, 0], elevator_deflection

def aircraft_eom(t, state, m, I, target_theta):
    # Unpack the state vector
    u, v, w, p, q, r, phi, theta, psi, x, y, z = state

    # Get control inputs from the control law
    forces, moments, elevator_deflection = control_law(state, target_theta)

    # Forces and moments
    Fx, Fy, Fz = forces
    Mx, My, Mz = moments

    # Inertia matrix components
    Ixx, Iyy, Izz = I

    # Translational equations of motion
    udot = r * v - q * w + Fx / m - g * np.sin(theta)
    vdot = p * w - r * u + Fy / m + g * np.cos(theta) * np.sin(phi)
    wdot = q * u - p * v + Fz / m + g * np.cos(theta) * np.cos(phi)

    # Rotational equations of motion
    pdot = (Iyy - Izz) / Ixx * q * r + Mx / Ixx
    qdot = (Izz - Ixx) / Iyy * r * p + My / Iyy
    rdot = (Ixx - Iyy) / Izz * p * q + Mz / Izz

    # Kinematic equations
    phidot = p + q * np.sin(phi) * np.tan(theta) + r * np.cos(phi) * np.tan(theta)
    thetadot = q * np.cos(phi) - r * np.sin(phi)
    psidot = q * np.sin(phi) / np.cos(theta) + r * np.cos(phi) / np.cos(theta)

    # Position updates
    xdot = u * np.cos(theta) * np.cos(psi) + v * (np.sin(phi) * np.sin(theta) * np.cos(psi) - np.cos(phi) * np.sin(psi)) + w * (np.cos(phi) * np.sin(theta) * np.cos(psi) + np.sin(phi) * np.sin(psi))
    ydot = u * np.cos(theta) * np.sin(psi) + v * (np.sin(phi) * np.sin(theta) * np.sin(psi) + np.cos(phi) * np.cos(psi)) + w * (np.cos(phi) * np.sin(theta) * np.sin(psi) - np.sin(phi) * np.cos(psi))
    zdot = -u * np.sin(theta) + v * np.sin(phi) * np.cos(theta) + w * np.cos(phi) * np.cos(theta)

    return [udot, vdot, wdot, pdot, qdot, rdot, phidot, thetadot, psidot, xdot, ydot, zdot]

# Function to check if the target altitude is reached
def check_target_altitude(state, target_altitude, tolerance=1):
    z = state[11]
    altitude_error = target_altitude + z
    return abs(altitude_error) < tolerance

# Time span for each simulation step
t_span = [0, 10]  # Extend time span to allow sufficient time for maneuver
max_iterations = 10000  # Extend max_iterations to avoid premature termination

# Store results
time = []
states = []
elevator_deflections = []

# Initial state
current_state = initial_state
current_time = 0
reached_target = False

# Target pitch angle for pull-up maneuver (gradual increase)
target_theta = 0.0

for i in range(max_iterations):
    if check_target_altitude(current_state, target_altitude):
        reached_target = True
        break

    solution = solve_ivp(aircraft_eom, t_span, current_state, args=(mass, I, target_theta), t_eval=np.linspace(0, t_span[1], 11))
    
    time.extend(current_time + solution.t)
    states.append(solution.y)
    
    # Store elevator deflection
    _, _, elevator_deflection = control_law(current_state, target_theta)
    elevator_deflections.append(elevator_deflection)
    
    current_state = solution.y[:, -1]
    current_time += t_span[1]

    # Increase target pitch angle gradually (towards 0)
    target_theta = np.arctan((target_altitude + current_state[11]) / current_state[9])

if not reached_target:
    print("Warning: Target altitude not reached within maximum iterations.")
else:
    if elevator_deflections:  # Ensure elevator_deflections is not empty
        print(f"Target altitude reached. Final elevator deflection: {elevator_deflections[-1]:.2f} degrees")
    else:
        print("Error: Elevator deflections list is empty.")

# Convert results to numpy arrays for plotting
time = np.array(time)
states = np.hstack(states)

# Extract x distance and altitude
x_distance = states[9]
altitude = -states[11]  # z is negative for altitude

# Plot results
plt.figure()
plt.plot(x_distance, altitude, label='Altitude vs X distance')
plt.xlabel('X Distance (m)')
plt.ylabel('Altitude (m)')
plt.legend()
plt.title('Altitude vs X Distance')
plt.grid()
plt.show()
